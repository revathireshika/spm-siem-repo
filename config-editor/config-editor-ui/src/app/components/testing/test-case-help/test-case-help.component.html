<mat-card>
    <mat-card-title>
        Json Path Cheat Sheet
    </mat-card-title>
    <mat-card-content>
        <h2>Operators</h2>
        <table>
            <tr>
                <td><h3>Operator</h3></td>
                <td><h3>Description</h3></td>
            </tr>
            <tr>
                <td><pre>$</pre></td>
                <td>The root element to query. This starts all path expressions.</td>
            </tr>
            <tr>
                <td><pre>@</pre></td>
                <td>The current node being processed by a filter predicate.</td>
            </tr>
            <tr>
                <td><pre>*</pre></td>
                <td>Wildcard. Available anywhere a name or numeric are required.</td>
            </tr>
            <tr>
                <td><pre>..</pre></td>
                <td>Deep scan. Available anywhere a name is required.</td>
            </tr>
            <tr>
                <td><pre>.&lt;name&gt;</pre></td>
                <td>Dot-notated child</td>
            </tr>
            <tr>
                <td><pre>[&#39;&lt;name&gt;&#39; (, &#39;&lt;name&gt;&#39;)]</pre></td>
                <td>Bracket-notated child or children</td>
            </tr>
            <tr>
                <td><pre>[&lt;number&gt; (, &lt;number&gt;)]</pre></td>
                <td>Array index or indexes</td>
            </tr>
            <tr>
                <td><pre>[start:end]</pre></td>
                <td>Array slice operator</td>
            </tr>
            <tr>
                <td><pre>[?(&lt;expression&gt;)]</pre></td>
                <td>Filter expression. Expression must evaluate to a boolean value.</td>
            </tr>
        </table>

        <mat-divider></mat-divider>

        <h2>Functions</h2>
        <p>Functions can be invoked at the tail end of a path - the input to a function is the output of the path expression. The function output is dictated by the function itself.</p>
        <table>
            <tr>
                <td><h3>Function</h3></td>
                <td><h3>Description</h3></td>
                <td><h3>Output</h3></td>
            </tr>
            <tr>
                <td><pre>min()</pre></td>
                <td>Provides the min value of an array of numbers</td>
                <td>Double</td>
            </tr>
            <tr>
                <td><pre>max()</pre></td>
                <td>Provides the max value of an array of numbers</td>
                <td>Double</td>
            </tr>
            <tr>
                <td><pre>avg()</pre></td>
                <td>Provides the average value of an array of numbers</td>
                <td>Double</td>
            </tr>
            <tr>
                <td><pre>stddev()</pre></td>
                <td>Provides the standard deviation value of an array of numbers</td>
                <td>Double</td>
            </tr>
            <tr>
                <td><pre>length()</pre></td>
                <td>Provides the length of an array</td>
                <td>Integer</td>
            </tr>
            <tr>
                <td><pre>sum()</pre></td>
                <td>Provides the sum value of an array of numbers</td>
                <td>Double</td>
            </tr>
        </table>

        <mat-divider></mat-divider>

        <h2>Filter Operators</h2>
        Filters are logical expressions used to filter arrays. A typical filter would be <pre>[?(@.age > 18)]</pre> where @ represents the current item being processed. More complex filters can be created with logical operators && and ||. String literals must be enclosed by single or double quotes <pre>([?(@.color == 'blue')]</pre> or <pre>[?(@.color == "blue")])</pre>
        <table>
            <tr>
                <td><h3>Operator</h3></td>
                <td><h3>Description</h3></td>
            </tr>
            <tr>
                <td><pre>==</pre></td>
                <td>left is equal to right (note that 1 is not equal to '1')</td>
            </tr>
            <tr>
                <td><pre>!=</pre></td>
                <td>left is not equal to right</td>
            </tr>
            <tr>
                <td><pre>&lt;</pre></td>
                <td>left is less than right</td>
            </tr>
            <tr>
                <td><pre>&lt;=</pre></td>
                <td>left is less or equal to right</td>
            </tr>
            <tr>
                <td><pre>&gt;</pre></td>
                <td>left is greater than right</td>
            </tr>
            <tr>
                <td><pre>&gt;=</pre></td>
                <td>left is greater than or equal to right</td>
            </tr>
            <tr>
                <td><pre>=~</pre></td>
                <td>left matches regular expression e.g. <pre>[?(@.name =~ /foo.*?/i)]</pre></td>
            </tr>
            <tr>
                <td><pre>in</pre></td>
                <td>left exists in right e.g. <pre>[?(@.size in [&#39;S&#39;, &#39;M&#39;])]</pre></td>
            </tr>
            <tr>
                <td><pre>nin</pre></td>
                <td>left does not exists in right</td>
            </tr>
            <tr>
                <td><pre>subsetof</pre></td>
                <td>left is a subset of right e.g. <pre>[?(@.sizes subsetof ['S', 'M', 'L'])]</pre></td>
            </tr>
            <tr>
                <td><pre>anyof</pre></td>
                <td>left has an intersection with right e.g. <pre>[?(@.sizes anyof ['M', 'L'])]</pre></td>
            </tr>
            <tr>
                <td><pre>noneof</pre></td>
                <td>left has no intersection with right e.g. <pre>[?(@.sizes noneof ['M', 'L'])]</pre></td>
            </tr>
            <tr>
                <td><pre>size</pre></td>
                <td>size of left (array or string) should match right</td>
            </tr>
            <tr>
                <td><pre>empty</pre></td>
                <td>left (array or string) should be empty</td>
            </tr>
        </table>
    </mat-card-content>
</mat-card>